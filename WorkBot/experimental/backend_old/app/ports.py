from __future__ import annotations
from typing import Protocol, Callable
from pathlib import Path
from backend.models.order import Order
from backend.models.transfer import Transfer

class OrderFilePort(Protocol):
    
    # Paths and Metadata
    def get_order_directory(self) -> Path: ...
    def get_order_file_path(self, order: Order, format: str = "excel") -> Path: ...
    def parse_filename_for_metadata(self, file_name: str) -> dict: ...
    def get_order_files(self, stores: list[str], vendors: list[str], formats: list[str] | None=None) -> list[Path]: ...
    
    # Persistence
    def save_order(self, order: Order, format: str = "excel") -> None: ...
    def archive_order_file(self, order: Order) -> None: ...
    def get_order_from_file(self, file_path: Path) -> Order: ...
    def remove_file(self, file_path: Path) -> None: ...
    def move_file(self, src: Path, dest: Path, overwrite: bool=False) -> None: ...
    
    # Business Logic
    def generate_vendor_upload_file(self, order: Order, context: dict | None=None) -> Path: ...
    def generate_vendor_upload_files(self, orders: list[Order], context: dict | None = None) -> Path: ...
    def combine_orders(self, vendors: list[str]) -> Path | None: ...

class OrderRepository(Protocol):
    def save_order(self, order: Order) -> int: ...

DownloadCallback = Callable[[Path], None]
class DownloadPort(Protocol):
    def on_download_once(self, match_fn: Callable[[Path], bool], callback: DownloadCallback, timeout: int=10) -> None: ...

class TransferFilePort(Protocol):

    def get_transfer_directory(self) -> Path: ...
    def get_transfer_file_path(self, transfer: Transfer, format: str = 'excel') -> Path: ...
    def parse_filename_for_metadata(self, file_name: str) -> dict: ...
    # def get_transfer_files(self, stores)